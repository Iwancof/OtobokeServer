!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/f6c7064a/
BufStream	server.rs	/^impl BufStream {$/;"	c
BufStream	server.rs	/^pub struct BufStream {$/;"	s
CommunicationProvider	network.rs	/^impl CommunicationProvider {$/;"	c
CommunicationProvider	network.rs	/^pub struct CommunicationProvider {$/;"	s
ExistVecTrait	algorithm.rs	/^trait ExistVecTrait<T> {$/;"	i
Game	game.rs	/^impl Game {$/;"	c
Game	game.rs	/^pub struct Game {$/;"	s
GameClient	map.rs	/^pub struct GameClient {$/;"	s
GameController	network.rs	/^impl GameController {$/;"	c
GameController	server.rs	/^impl Drop for GameController {$/;"	c
GameController	server.rs	/^impl GameController {$/;"	c
GameController	server.rs	/^pub struct GameController {$/;"	s
LoopTimer	time.rs	/^impl LoopTimer {$/;"	c
LoopTimer	time.rs	/^pub struct LoopTimer {$/;"	s
LoopTimerUnArc	time.rs	/^impl LoopTimerUnArc {$/;"	c
LoopTimerUnArc	time.rs	/^pub struct LoopTimerUnArc {$/;"	s
MapInfo	map.rs	/^impl MapInfo {$/;"	c
MapInfo	map.rs	/^pub struct MapInfo {$/;"	s
MapProcAsGame	algorithm.rs	/^impl MapProcAsGame { \/\/ for AI$/;"	c
MapProcAsGame	map.rs	/^impl MapProcAsGame {$/;"	c
MapProcAsGame	map.rs	/^pub struct MapProcAsGame {$/;"	s
Message	time.rs	/^pub enum Message {$/;"	g
Normal	map.rs	/^    Normal,$/;"	e	enum:PMState
Output	map.rs	/^    type Output = Self;$/;"	t	implementation:QuanCoord
PMState	map.rs	/^pub enum PMState {$/;"	g
Powered	map.rs	/^    Powered(Sender<time::Message>), \/\/ this sender is to stop thread. $/;"	e	enum:PMState
ProgressAndGoal	time.rs	/^impl<T: PartialOrd + Add<Output = T> + Sub<Output = T> + Copy> ProgressAndGoal<T> {$/;"	c
ProgressAndGoal	time.rs	/^pub struct ProgressAndGoal<T: PartialOrd + Add + Sub + Copy> {$/;"	s
QuanCoord	map.rs	/^impl QuanCoord {$/;"	c
QuanCoord	map.rs	/^impl Sub for QuanCoord {$/;"	c
QuanCoord	map.rs	/^impl fmt::Display for QuanCoord {$/;"	c
QuanCoord	map.rs	/^pub struct QuanCoord {$/;"	s
RawCoord	map.rs	/^impl RawCoord {$/;"	c
RawCoord	map.rs	/^pub struct RawCoord {$/;"	s
RawRxTimer	time.rs	/^pub struct RawRxTimer {$/;"	s
RxTimerTrait	time.rs	/^trait RxTimerTrait {$/;"	i
Stop	time.rs	/^    Stop,$/;"	e	enum:Message
Vec	algorithm.rs	/^impl<T: PartialEq> ExistVecTrait<T> for Vec<T> {$/;"	c
access_by_coord_game_based_system	map.rs	/^    pub fn access_by_coord_game_based_system(&self, mut coord: QuanCoord) -> i32 {$/;"	P	implementation:MapInfo
access_by_coord_game_based_system_mutref	map.rs	/^    pub fn access_by_coord_game_based_system_mutref(&mut self, mut coord: QuanCoord) -> &mut i32/;"	P	implementation:MapInfo
access_by_coord_index_based_converted_system	map.rs	/^    pub fn access_by_coord_index_based_converted_system(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
access_by_coord_index_based_converted_system_mutref	map.rs	/^    pub fn access_by_coord_index_based_converted_system_mutref(&mut self, x: i32, y: i32) -> &mu/;"	P	implementation:MapInfo
acs_onvoid	map.rs	/^    pub fn acs_onvoid(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
add	time.rs	/^    pub fn add(&mut self, pg: T) -> bool {$/;"	P	implementation:ProgressAndGoal
algorithm	main.rs	/^mod algorithm;$/;"	n
announce_message	network.rs	/^    pub fn announce_message(&self, msg: String) {$/;"	P	implementation:CommunicationProvider
announce_message_byte	network.rs	/^    pub fn announce_message_byte(&self, msg: &[u8]) {$/;"	P	implementation:CommunicationProvider
announce_wrap	network.rs	/^    pub fn announce_wrap(&self, msg: String) {$/;"	P	implementation:GameController
anti_quantize	map.rs	/^    pub fn anti_quantize(&self) -> RawCoord {$/;"	P	implementation:QuanCoord
build_by_filename	map.rs	/^    pub fn build_by_filename(file_name: String) -> Self {$/;"	P	implementation:MapInfo
build_by_string	map.rs	/^    pub fn build_by_string(map_data: String) -> Self {$/;"	P	implementation:MapInfo
clear_paced_collection	game.rs	/^    pub fn clear_paced_collection(&mut self) {$/;"	P	implementation:Game
clients	network.rs	/^    pub clients: Vec<Arc<Mutex<TcpStream>>>, $/;"	m	struct:CommunicationProvider
clients_count	network.rs	/^    pub fn clients_count(&self) -> usize {$/;"	P	implementation:CommunicationProvider
comn_prov	server.rs	/^    pub comn_prov: Arc<Mutex<CommunicationProvider>>,$/;"	m	struct:GameController
coord	map.rs	/^    pub coord: QuanCoord,$/;"	m	struct:GameClient
coordinate_to_json	game.rs	/^    pub fn coordinate_to_json(&self) -> String {$/;"	P	implementation:Game
coordinate_to_json_pacman	game.rs	/^    pub fn coordinate_to_json_pacman(&self) -> String {$/;"	P	implementation:Game
count	time.rs	/^    count: usize,$/;"	m	struct:LoopTimerUnArc
count_at	map.rs	/^    pub fn count_at(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
create_map_mock	map.rs	/^fn create_map_mock() -> MapInfo {$/;"	f
create_map_proc_as_game_mock	map.rs	/^fn create_map_proc_as_game_mock() -> MapProcAsGame {$/;"	f
dist	map.rs	/^    pub fn dist(a: QuanCoord, b: QuanCoord) -> f32 {$/;"	P	implementation:QuanCoord
distance_to_coord	map.rs	/^    pub fn distance_to_coord(&self, other: Self) -> f64 {$/;"	P	implementation:QuanCoord
distance_to_element	map.rs	/^    pub fn distance_to_element(&self, x: i32, y: i32) -> f64 {$/;"	P	implementation:QuanCoord
distribute_map	server.rs	/^    pub fn distribute_map(&mut self) {$/;"	P	implementation:GameController
drop	server.rs	/^    fn drop(&mut self) {$/;"	P	implementation:GameController
evaluate_at	algorithm.rs	/^    pub fn evaluate_at(&mut self, pos: QuanCoord) -> f64 {$/;"	P	implementation:MapProcAsGame
exist_in	algorithm.rs	/^    fn exist_in(&self, e: T) -> bool {$/;"	P	implementation:Vec
exist_in	algorithm.rs	/^    fn exist_in(&self, e: T) -> bool;$/;"	P	interface:ExistVecTrait
exist_vec_trait_test	algorithm.rs	/^fn exist_vec_trait_test() {$/;"	f
field	map.rs	/^    pub field: Vec<Vec<i32>>,$/;"	m	struct:MapInfo
field_access_test	map.rs	/^fn field_access_test() {$/;"	f
fmt	map.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	P	implementation:QuanCoord
game	main.rs	/^mod game;$/;"	n
game	server.rs	/^    pub game: Arc<Mutex<Game>>,$/;"	m	struct:GameController
game_id	game.rs	/^    pub game_id: i32,$/;"	m	struct:Game
game_init_call_once	game.rs	/^    pub fn game_init_call_once(&mut self) {$/;"	P	implementation:Game
game_initialize	server.rs	/^    pub fn game_initialize(&mut self) {$/;"	P	implementation:GameController
get_can_move_on	map.rs	/^    pub fn get_can_move_on(&self, now_pos: QuanCoord) -> Vec<QuanCoord> {$/;"	P	implementation:MapInfo
get_inferpoints	map.rs	/^    pub fn get_inferpoints(&self) -> Vec<QuanCoord> {$/;"	P	implementation:MapInfo
get_paced_coordinates_as_raw	game.rs	/^    pub fn get_paced_coordinates_as_raw(&self) -> Vec<QuanCoord> {$/;"	P	implementation:Game
goal	time.rs	/^    pub goal: T,$/;"	m	struct:ProgressAndGoal
height	map.rs	/^    pub height: usize,$/;"	m	struct:MapInfo
is_map_chip	map.rs	/^    fn is_map_chip(v: i32) -> bool {$/;"	P	implementation:MapInfo
item	time.rs	/^    item: Arc<Mutex<LoopTimerUnArc>>,$/;"	m	struct:LoopTimer
json	main.rs	/^mod json;$/;"	n
json_build	json.rs	/^pub fn json_build<T: Serialize>(tag: &str, name: &str, object: &T) -> String {$/;"	f
json_build_vec	json.rs	/^pub fn json_build_vec<T: Serialize>(tag: &str, name: &str, v: &Vec<T>) -> String {$/;"	f
latest	time.rs	/^    latest: Instant, \/\/ latest time.$/;"	m	struct:RawRxTimer
latest	time.rs	/^    latest: Instant,$/;"	m	struct:LoopTimerUnArc
limits	time.rs	/^    limits: Vec<u128>,$/;"	m	struct:LoopTimerUnArc
main	main.rs	/^fn main() { \/\/For one game$/;"	f
map	main.rs	/^mod map;$/;"	n
map	map.rs	/^    pub map: MapInfo,$/;"	m	struct:MapProcAsGame
map_element_bias_with_dist	algorithm.rs	/^    fn map_element_bias_with_dist(dist: f64) -> f64 {$/;"	P	implementation:MapProcAsGame
map_file_import_test	map.rs	/^fn map_file_import_test() {$/;"	f
map_mock_valid_test	map.rs	/^fn map_mock_valid_test() {$/;"	f
map_proc	game.rs	/^    pub map_proc: Arc<Mutex<MapProcAsGame>>,$/;"	m	struct:Game
map_to_string	map.rs	/^    pub fn map_to_string(&self) -> String {$/;"	P	implementation:MapInfo
move_pacman	algorithm.rs	/^    pub fn move_pacman(&mut self) {$/;"	P	implementation:MapProcAsGame
move_pacman_wrap	game.rs	/^    pub fn move_pacman_wrap(&mut self) {$/;"	P	implementation:Game
move_to	algorithm.rs	/^    pub fn move_to(&mut self, coord: QuanCoord) -> Result<QuanCoord, QuanCoord>{$/;"	P	implementation:MapProcAsGame
move_to_non_teleport_point_test	map.rs	/^fn move_to_non_teleport_point_test() {$/;"	f
move_to_teleport_point_test	map.rs	/^fn move_to_teleport_point_test() {$/;"	f
network	main.rs	/^mod network;$/;"	n
network_buffer	network.rs	/^    pub network_buffer : Vec<Arc<Mutex<String>>>,$/;"	m	struct:CommunicationProvider
new	game.rs	/^    pub fn new(map: MapInfo, num_of_player: usize) -> Self {$/;"	P	implementation:Game
new	map.rs	/^    pub fn new(map: MapInfo, player_number: usize) -> Self {$/;"	P	implementation:MapProcAsGame
new	network.rs	/^    pub fn new() -> Self {$/;"	P	implementation:CommunicationProvider
new	server.rs	/^    pub fn new(game: Game) -> GameController {$/;"	P	implementation:GameController
new	server.rs	/^    pub fn new(stream: &TcpStream) -> BufStream {$/;"	P	implementation:BufStream
new	time.rs	/^    pub fn new() -> LoopTimer {$/;"	P	implementation:LoopTimer
new	time.rs	/^    pub fn new() -> LoopTimerUnArc {$/;"	P	implementation:LoopTimerUnArc
number_of_player	game.rs	/^    pub number_of_player: usize,$/;"	m	struct:Game
open_server	main.rs	/^fn open_server(game: game::Game) {$/;"	f
paced_collection	map.rs	/^    pub paced_collection: Arc<Mutex<Vec<QuanCoord>>>,$/;"	m	struct:MapProcAsGame
paced_vec_to_string	game.rs	/^pub fn paced_vec_to_string(v : Vec<QuanCoord>) -> String {$/;"	f
pacman	map.rs	/^    pub pacman: QuanCoord,$/;"	m	struct:MapProcAsGame
parse_client_info	network.rs	/^pub fn parse_client_info(msg: String) -> Vec<f32> {$/;"	f
player_join	network.rs	/^    pub fn player_join(&mut self,stream: net::TcpStream) {$/;"	P	implementation:GameController
player_join_initialize	network.rs	/^    pub fn player_join_initialize(&mut self, stream: net::TcpStream) {$/;"	P	implementation:GameController
player_limit	server.rs	/^    pub player_limit: usize,$/;"	m	struct:GameController
player_pos_bias_with_dist	algorithm.rs	/^    fn player_pos_bias_with_dist(dist: f64) -> f64 {$/;"	P	implementation:MapProcAsGame
players	map.rs	/^    pub players: Vec<GameClient>, $/;"	m	struct:MapProcAsGame
plus_element_x	map.rs	/^    pub fn plus_element_x(&self, x: i32) -> Self {$/;"	P	implementation:QuanCoord
plus_element_y	map.rs	/^    pub fn plus_element_y(&self, y: i32) -> Self {$/;"	P	implementation:QuanCoord
pm_inferpoints	map.rs	/^    pub pm_inferpoints: Vec<QuanCoord>,$/;"	m	struct:MapProcAsGame
pm_prev_place	map.rs	/^    pub pm_prev_place: QuanCoord,$/;"	m	struct:MapProcAsGame
pm_score	game.rs	/^    pub pm_score: i32,$/;"	m	struct:Game
pm_state	map.rs	/^    pub pm_state: Arc<Mutex<PMState>>,$/;"	m	struct:MapProcAsGame
pm_target	map.rs	/^    pub pm_target: usize,$/;"	m	struct:MapProcAsGame
print_on	main.rs	/^fn print_on(msg: String, wos: usize, hos: usize) {$/;"	f
progress	time.rs	/^    pub progress: T,$/;"	m	struct:ProgressAndGoal
quantize	map.rs	/^    pub fn quantize(&self) -> QuanCoord {$/;"	P	implementation:RawCoord
raw_coord	map.rs	/^    pub raw_coord: RawCoord,$/;"	m	struct:GameClient
rd	server.rs	/^    pub rd: BufReader<TcpStream>,$/;"	m	struct:BufStream
read_by_buffer	network.rs	/^pub fn read_by_buffer(br: Arc<Mutex<BufStream>>) -> String {$/;"	f
register_player	server.rs	/^    pub fn register_player(&self) {$/;"	P	implementation:GameController
routed_next_point	algorithm.rs	/^    pub fn routed_next_point(&self, movable_points: Vec<QuanCoord>) -> QuanCoord {$/;"	P	implementation:MapProcAsGame
routed_next_point_test	map.rs	/^fn routed_next_point_test() {$/;"	f
search_movable_point_test	map.rs	/^fn search_movable_point_test() {$/;"	f
send_message	network.rs	/^pub fn send_message(mut stream: &net::TcpStream,msg: String) -> Result<usize, Error> {$/;"	f
send_message_byte	network.rs	/^pub fn send_message_byte(mut stream: &net::TcpStream,msg: &[u8]) -> Result<usize, Error> {$/;"	f
serialize_test	json.rs	/^fn serialize_test() {$/;"	f
server	main.rs	/^mod server;$/;"	n
show_game_details	server.rs	/^    pub fn show_game_details(&self) {$/;"	P	implementation:GameController
show_map	map.rs	/^    pub fn show_map(&self) {$/;"	P	implementation:MapInfo
start	time.rs	/^    pub fn start(&mut self) {$/;"	P	implementation:LoopTimer
start_game	server.rs	/^    pub fn start_game(&mut self) {$/;"	P	implementation:GameController
start_reading_coordinate	network.rs	/^pub fn start_reading_coordinate(stream: &Vec<Arc<Mutex<BufStream>>>, data_buffer_non_static: &mu/;"	f
sub	map.rs	/^    fn sub(self, other: Self) -> Self {$/;"	P	implementation:QuanCoord
subscribe	time.rs	/^    fn subscribe(&mut self, task: Box<dyn Fn() -> () + Send>, frec: u128) -> Result<usize, Strin/;"	P	interface:RxTimerTrait
subscribe	time.rs	/^    pub fn subscribe(&mut self, func : Box<dyn Fn() -> () + Send>, limit : u128) -> usize {$/;"	P	implementation:LoopTimerUnArc
subscribe	time.rs	/^    pub fn subscribe(&mut self, func: Box<dyn Fn() -> () + Send>, limit: u128) -> usize {$/;"	P	implementation:LoopTimer
subscribe_test	time.rs	/^pub fn subscribe_test() {$/;"	f
task_time_totals	time.rs	/^    task_time_totals: Vec<ProgressAndGoal<u128>>,$/;"	m	struct:RawRxTimer
tasks	time.rs	/^    tasks: Vec<Box<dyn Fn() -> () + Send>>,$/;"	m	struct:LoopTimerUnArc
tasks	time.rs	/^    tasks: Vec<Box<dyn Fn() -> () + Send>>,$/;"	m	struct:RawRxTimer
time	main.rs	/^mod time;$/;"	n
time_task_reservation	time.rs	/^pub fn time_task_reservation(task: impl(Fn() -> ()) + Send + 'static, span: Duration) -> Sender</;"	f
time_task_reservation_cancel_test	time.rs	/^fn time_task_reservation_cancel_test() {$/;"	f
time_task_reservation_non_cancel_test	time.rs	/^fn time_task_reservation_non_cancel_test() {$/;"	f
timer	server.rs	/^    pub timer: LoopTimer, \/\/This is doing tasks per the time$/;"	m	struct:GameController
torus_form	map.rs	/^    pub fn torus_form(&self, map_ptr: &MapInfo) -> Self {$/;"	P	implementation:QuanCoord
totals	time.rs	/^    totals: Vec<u128>,$/;"	m	struct:LoopTimerUnArc
unique_field_element_search_test	map.rs	/^fn unique_field_element_search_test() {$/;"	f
unique_points	map.rs	/^    pub unique_points: HashMap<i32, QuanCoord>,$/;"	m	struct:MapInfo
update	time.rs	/^    fn update(&mut self);$/;"	P	interface:RxTimerTrait
update	time.rs	/^    pub fn update(&mut self) {$/;"	P	implementation:LoopTimerUnArc
update_coordinate	game.rs	/^    pub fn update_coordinate(&mut self, i: usize, v: Vec<f32>) {$/;"	P	implementation:Game
vec_group_eq	map.rs	/^fn vec_group_eq<T: PartialEq>(v: &Vec<T>, w: &Vec<T>) -> bool {$/;"	f
vec_group_eq_test	map.rs	/^fn vec_group_eq_test() {$/;"	f
wait_and_prepare_commication	server.rs	/^    pub fn wait_and_prepare_commication(&mut self) {$/;"	P	implementation:GameController
wait_for_players	server.rs	/^    pub fn wait_for_players(&mut self) {$/;"	P	implementation:GameController
width	map.rs	/^    pub width: usize,$/;"	m	struct:MapInfo
wr	server.rs	/^    pub wr: BufWriter<TcpStream>,$/;"	m	struct:BufStream
x	map.rs	/^    pub x: f32,$/;"	m	struct:RawCoord
x	map.rs	/^    pub x: i32,$/;"	m	struct:QuanCoord
y	map.rs	/^    pub y: f32,$/;"	m	struct:RawCoord
y	map.rs	/^    pub y: i32,$/;"	m	struct:QuanCoord
z	map.rs	/^    pub z: f32, \/\/ clients(Unity) send z data.$/;"	m	struct:RawCoord
