!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/f6c7064a/
Arc	server/communication.rs	/^impl CommunicationProviderTrait for Arc<Mutex<CommunicationProvider>> {$/;"	c
BufStream	server/communication.rs	/^impl BufStream {$/;"	c
BufStream	server/communication.rs	/^pub struct BufStream {$/;"	s
CommunicationProvider	server/communication.rs	/^impl CommunicationProvider {$/;"	c
CommunicationProvider	server/communication.rs	/^impl CommunicationProviderTrait for CommunicationProvider {$/;"	c
CommunicationProvider	server/communication.rs	/^pub struct CommunicationProvider {$/;"	s
CommunicationProviderTrait	server/communication.rs	/^pub trait CommunicationProviderTrait {$/;"	i
ExistVecTrait	map/map_alg.rs	/^trait ExistVecTrait<T> {$/;"	i
Game	game.rs	/^impl Game {$/;"	c
Game	game.rs	/^pub struct Game {$/;"	s
GameClient	map/mod.rs	/^pub struct GameClient {$/;"	s
GameController	server/communication.rs	/^impl GameController {$/;"	c
GameController	server/game_parents.rs	/^impl GameController {$/;"	c
GameController	server/mod.rs	/^pub struct GameController {$/;"	s
GameController	server/server_interface.rs	/^impl GameController {$/;"	c
GameController	server/server_utils.rs	/^impl Drop for GameController {$/;"	c
GameController	server/server_utils.rs	/^impl GameController {$/;"	c
LoopTimer	time.rs	/^impl LoopTimer {$/;"	c
LoopTimer	time.rs	/^pub struct LoopTimer {$/;"	s
LoopTimerUnArc	time.rs	/^impl LoopTimerUnArc {$/;"	c
LoopTimerUnArc	time.rs	/^pub struct LoopTimerUnArc {$/;"	s
MapInfo	map/mapinfo_access.rs	/^impl MapInfo {$/;"	c
MapInfo	map/mapinfo_utils.rs	/^impl MapInfo {$/;"	c
MapInfo	map/mod.rs	/^pub struct MapInfo {$/;"	s
MapProcAsGame	map/map_alg.rs	/^impl MapProcAsGame { \/\/ for AI$/;"	c
MapProcAsGame	map/mod.rs	/^pub struct MapProcAsGame {$/;"	s
Message	time.rs	/^pub enum Message {$/;"	g
Normal	map/mod.rs	/^    Normal,$/;"	e	enum:PMState
Output	map/coord.rs	/^    type Output = Self;$/;"	t	implementation:QuanCoord
PMState	map/mod.rs	/^impl ToString for PMState {$/;"	c
PMState	map/mod.rs	/^pub enum PMState {$/;"	g
Powered	map/mod.rs	/^    Powered(Sender<time::Message>), \/\/ this sender is to stop thread. $/;"	e	enum:PMState
ProgressAndGoal	time.rs	/^impl<T: PartialOrd + Add<Output = T> + Sub<Output = T> + Copy> ProgressAndGoal<T> {$/;"	c
ProgressAndGoal	time.rs	/^pub struct ProgressAndGoal<T: PartialOrd + Add + Sub + Copy> {$/;"	s
ProviderResult	server/communication.rs	/^type ProviderResult = Result<usize, std::io::Error>;$/;"	t
QuanCoord	map/coord.rs	/^impl QuanCoord {$/;"	c
QuanCoord	map/coord.rs	/^impl Sub for QuanCoord {$/;"	c
QuanCoord	map/coord.rs	/^impl fmt::Display for QuanCoord {$/;"	c
QuanCoord	map/coord.rs	/^pub struct QuanCoord {$/;"	s
RawCoord	map/coord.rs	/^impl RawCoord {$/;"	c
RawCoord	map/coord.rs	/^pub struct RawCoord {$/;"	s
RawRxTimer	time.rs	/^pub struct RawRxTimer {$/;"	s
RxTimerTrait	time.rs	/^trait RxTimerTrait {$/;"	i
Stop	time.rs	/^    Stop,$/;"	e	enum:Message
Vec	map/map_alg.rs	/^impl<T: PartialEq> ExistVecTrait<T> for Vec<T> {$/;"	c
accept_client_stream	server/server_utils.rs	/^    pub fn accept_client_stream(&self, mut stream: net::TcpStream) {$/;"	P	implementation:GameController
access_by_coord_game_based_system	map/mapinfo_access.rs	/^    pub fn access_by_coord_game_based_system(&self, mut coord: QuanCoord) -> i32 {$/;"	P	implementation:MapInfo
access_by_coord_game_based_system_mutref	map/mapinfo_access.rs	/^    pub fn access_by_coord_game_based_system_mutref(&mut self, mut coord: QuanCoord) -> &mut i32/;"	P	implementation:MapInfo
access_by_coord_index_based_converted_system	map/mapinfo_access.rs	/^    pub fn access_by_coord_index_based_converted_system(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
access_by_coord_index_based_converted_system_mutref	map/mapinfo_access.rs	/^    pub fn access_by_coord_index_based_converted_system_mutref(&mut self, x: i32, y: i32) -> &mu/;"	P	implementation:MapInfo
acs_onvoid	map/mapinfo_access.rs	/^    pub fn acs_onvoid(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
add	time.rs	/^    pub fn add(&mut self, pg: T) -> bool {$/;"	P	implementation:ProgressAndGoal
announce_wrap	server/communication.rs	/^    pub fn announce_wrap(&self, msg: String){$/;"	P	implementation:GameController
anti_quantize	map/coord.rs	/^    pub fn anti_quantize(&self) -> RawCoord {$/;"	P	implementation:QuanCoord
build_by_filename	map/mapinfo_utils.rs	/^    pub fn build_by_filename(file_name: String) -> Self {$/;"	P	implementation:MapInfo
build_by_string	map/mapinfo_utils.rs	/^    pub fn build_by_string(map_data: String) -> Self {$/;"	P	implementation:MapInfo
clients	server/communication.rs	/^    pub clients: Vec<Arc<Mutex<BufStream>>>, $/;"	m	struct:CommunicationProvider
clients_count	server/communication.rs	/^    fn clients_count(&self) -> usize {$/;"	P	implementation:CommunicationProvider
communication	server/mod.rs	/^pub mod communication;$/;"	n
comn_prov	map/mod.rs	/^    pub comn_prov: Option<Arc<Mutex<CommunicationProvider>>>,$/;"	m	struct:MapProcAsGame
comn_prov	server/mod.rs	/^    pub comn_prov: Arc<Mutex<CommunicationProvider>>,$/;"	m	struct:GameController
coord	map/mod.rs	/^    pub coord: QuanCoord,$/;"	m	struct:GameClient
coord	map/mod.rs	/^pub mod coord;$/;"	n
coordinate_to_json	game.rs	/^    pub fn coordinate_to_json(&self) -> String {$/;"	P	implementation:Game
coordinate_to_json_pacman	game.rs	/^    pub fn coordinate_to_json_pacman(&self) -> String {$/;"	P	implementation:Game
count	time.rs	/^    count: usize,$/;"	m	struct:LoopTimerUnArc
count_at	map/mapinfo_access.rs	/^    pub fn count_at(&self, x: i32, y: i32) -> i32 {$/;"	P	implementation:MapInfo
create_map_mock	map/test.rs	/^fn create_map_mock() -> MapInfo {$/;"	f
create_map_proc_as_game_mock	map/test.rs	/^fn create_map_proc_as_game_mock() -> MapProcAsGame {$/;"	f
data_factory	server/mod.rs	/^pub mod data_factory;$/;"	n
dist	map/coord.rs	/^    pub fn dist(a: QuanCoord, b: QuanCoord) -> f32 {$/;"	P	implementation:QuanCoord
distance_to_coord	map/coord.rs	/^    pub fn distance_to_coord(&self, other: Self) -> f64 {$/;"	P	implementation:QuanCoord
distance_to_element	map/coord.rs	/^    pub fn distance_to_element(&self, x: i32, y: i32) -> f64 {$/;"	P	implementation:QuanCoord
distribute_map	server/game_parents.rs	/^    pub(super) fn distribute_map(&mut self) {$/;"	P	implementation:GameController
drop	server/server_utils.rs	/^    fn drop(&mut self) {$/;"	P	implementation:GameController
evaluate_at	map/map_alg.rs	/^    pub fn evaluate_at(&mut self, pos: QuanCoord) -> f64 {$/;"	P	implementation:MapProcAsGame
exist_in	map/map_alg.rs	/^    fn exist_in(&self, e: T) -> bool {$/;"	P	implementation:Vec
exist_in	map/map_alg.rs	/^    fn exist_in(&self, e: T) -> bool;$/;"	P	interface:ExistVecTrait
exist_vec_trait_test	map/map_alg.rs	/^fn exist_vec_trait_test() {$/;"	f
field	map/mod.rs	/^    pub field: Vec<Vec<i32>>,$/;"	m	struct:MapInfo
field_access_test	map/test.rs	/^fn field_access_test() {$/;"	f
fmt	map/coord.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	P	implementation:QuanCoord
front	server/mod.rs	/^pub mod front;$/;"	n
game	main.rs	/^mod game;$/;"	n
game	server/mod.rs	/^    pub game: Arc<Mutex<Game>>,$/;"	m	struct:GameController
game_id	game.rs	/^    pub game_id: i32,$/;"	m	struct:Game
game_initialize	server/game_parents.rs	/^    pub(super) fn game_initialize(&mut self) {$/;"	P	implementation:GameController
game_parents	server/mod.rs	/^pub mod game_parents;$/;"	n
get_can_move_on	map/mapinfo_utils.rs	/^    pub fn get_can_move_on(&self, now_pos: QuanCoord) -> Vec<QuanCoord> {$/;"	P	implementation:MapInfo
get_inferpoints	map/mapinfo_utils.rs	/^    pub fn get_inferpoints(&self) -> Vec<QuanCoord> {$/;"	P	implementation:MapInfo
goal	time.rs	/^    pub goal: T,$/;"	m	struct:ProgressAndGoal
height	map/mod.rs	/^    pub height: usize,$/;"	m	struct:MapInfo
is_map_chip	map/mapinfo_utils.rs	/^    fn is_map_chip(v: i32) -> bool {$/;"	P	implementation:MapInfo
item	time.rs	/^    item: Arc<Mutex<LoopTimerUnArc>>,$/;"	m	struct:LoopTimer
join_client_stream	server/server_utils.rs	/^    pub fn join_client_stream(&self, stream: net::TcpStream) {$/;"	P	implementation:GameController
json	main.rs	/^mod json;$/;"	n
json_build	json.rs	/^pub fn json_build<T: Serialize>(tag: &str, name: &str, object: &T) -> String {$/;"	f
json_build_vec	json.rs	/^pub fn json_build_vec<T: Serialize>(tag: &str, name: &str, v: &Vec<T>) -> String {$/;"	f
latest	time.rs	/^    latest: Instant, \/\/ latest time.$/;"	m	struct:RawRxTimer
latest	time.rs	/^    latest: Instant,$/;"	m	struct:LoopTimerUnArc
limits	time.rs	/^    limits: Vec<u128>,$/;"	m	struct:LoopTimerUnArc
main	main.rs	/^fn main() { \/\/For one game$/;"	f
map	main.rs	/^mod map;$/;"	n
map	map/mod.rs	/^    pub map: MapInfo,$/;"	m	struct:MapProcAsGame
map_alg	map/mod.rs	/^pub mod map_alg;$/;"	n
map_element_bias_with_dist	map/map_alg.rs	/^    fn map_element_bias_with_dist(dist: f64) -> f64 {$/;"	P	implementation:MapProcAsGame
map_file_import_test	map/test.rs	/^fn map_file_import_test() {$/;"	f
map_mock_valid_test	map/test.rs	/^fn map_mock_valid_test() {$/;"	f
map_proc	game.rs	/^    pub map_proc: Arc<Mutex<MapProcAsGame>>,$/;"	m	struct:Game
map_to_string	map/mapinfo_access.rs	/^    pub fn map_to_string(&self) -> String {$/;"	P	implementation:MapInfo
mapinfo_access	map/mod.rs	/^pub mod mapinfo_access;$/;"	n
mapinfo_utils	map/mod.rs	/^pub mod mapinfo_utils;$/;"	n
move_pacman	map/map_alg.rs	/^    pub fn move_pacman(&mut self) {$/;"	P	implementation:MapProcAsGame
move_pacman_wrap	game.rs	/^    pub fn move_pacman_wrap(&mut self) {$/;"	P	implementation:Game
move_to	map/map_alg.rs	/^    pub fn move_to(&mut self, coord: QuanCoord) -> Result<QuanCoord, QuanCoord>{$/;"	P	implementation:MapProcAsGame
move_to_non_teleport_point_test	map/test.rs	/^fn move_to_non_teleport_point_test() {$/;"	f
move_to_teleport_point_test	map/test.rs	/^fn move_to_teleport_point_test() {$/;"	f
network_buffer	server/communication.rs	/^    pub network_buffer : Vec<Arc<Mutex<String>>>,$/;"	m	struct:CommunicationProvider
new	game.rs	/^    pub fn new(map: MapInfo, num_of_player: usize) -> Self {$/;"	P	implementation:Game
new	map/map_alg.rs	/^    pub fn new(map: MapInfo) -> Self {$/;"	P	implementation:MapProcAsGame
new	server/communication.rs	/^    pub fn new() -> Self {$/;"	P	implementation:CommunicationProvider
new	server/communication.rs	/^    pub fn new(stream: &TcpStream) -> BufStream {$/;"	P	implementation:BufStream
new	server/server_utils.rs	/^    pub fn new(game: Game) -> GameController {$/;"	P	implementation:GameController
new	time.rs	/^    pub fn new() -> LoopTimer {$/;"	P	implementation:LoopTimer
new	time.rs	/^    pub fn new() -> LoopTimerUnArc {$/;"	P	implementation:LoopTimerUnArc
number_of_player	game.rs	/^    pub number_of_player: usize,$/;"	m	struct:Game
pac_cookie_at	map/map_alg.rs	/^    fn pac_cookie_at(&mut self, coord: QuanCoord) {$/;"	P	implementation:MapProcAsGame
paced_vec_to_string	game.rs	/^pub fn paced_vec_to_string(v : Vec<QuanCoord>) -> String {$/;"	f
pacman	map/mod.rs	/^    pub pacman: QuanCoord,$/;"	m	struct:MapProcAsGame
pacman_state_change_notify	map/map_alg.rs	/^    fn pacman_state_change_notify<T: CommunicationProviderTrait>(prov: T, state: Arc<Mutex<PMSta/;"	P	implementation:MapProcAsGame
parse_client_info	server/communication.rs	/^    pub(super) fn parse_client_info(msg: String) -> Vec<f32> {$/;"	P	implementation:GameController
player_info_initialize_in_map	server/server_utils.rs	/^    pub(super) fn player_info_initialize_in_map(&self) {$/;"	P	implementation:GameController
player_limit	server/mod.rs	/^    pub player_limit: usize,$/;"	m	struct:GameController
player_pos_bias_with_dist	map/map_alg.rs	/^    fn player_pos_bias_with_dist(dist: f64) -> f64 {$/;"	P	implementation:MapProcAsGame
players	map/mod.rs	/^    pub players: Vec<GameClient>, $/;"	m	struct:MapProcAsGame
plus_element_x	map/coord.rs	/^    pub fn plus_element_x(&self, x: i32) -> Self {$/;"	P	implementation:QuanCoord
plus_element_y	map/coord.rs	/^    pub fn plus_element_y(&self, y: i32) -> Self {$/;"	P	implementation:QuanCoord
pm_inferpoints	map/mod.rs	/^    pub pm_inferpoints: Vec<QuanCoord>,$/;"	m	struct:MapProcAsGame
pm_prev_place	map/mod.rs	/^    pub pm_prev_place: QuanCoord,$/;"	m	struct:MapProcAsGame
pm_score	game.rs	/^    pub pm_score: i32,$/;"	m	struct:Game
pm_state	map/mod.rs	/^    pub pm_state: Arc<Mutex<PMState>>,$/;"	m	struct:MapProcAsGame
pm_target	map/mod.rs	/^    pub pm_target: usize,$/;"	m	struct:MapProcAsGame
print_on	main.rs	/^fn print_on(msg: String, wos: usize, hos: usize) {$/;"	f
progress	time.rs	/^    pub progress: T,$/;"	m	struct:ProgressAndGoal
quantize	map/coord.rs	/^    pub fn quantize(&self) -> QuanCoord {$/;"	P	implementation:RawCoord
raw_coord	map/mod.rs	/^    pub raw_coord: RawCoord,$/;"	m	struct:GameClient
rd	server/communication.rs	/^    pub rd: BufReader<TcpStream>,$/;"	m	struct:BufStream
read_by_buffer	server/communication.rs	/^pub fn read_by_buffer(bs: Arc<Mutex<BufStream>>) -> String {$/;"	f
read_string	server/communication.rs	/^    pub fn read_string(&mut self) -> String {$/;"	P	implementation:BufStream
routed_next_point	map/map_alg.rs	/^    pub fn routed_next_point(&self, movable_points: Vec<QuanCoord>) -> QuanCoord {$/;"	P	implementation:MapProcAsGame
routed_next_point_test	map/test.rs	/^fn routed_next_point_test() {$/;"	f
search_movable_point_test	map/test.rs	/^fn search_movable_point_test() {$/;"	f
send	server/communication.rs	/^    fn send(&self, msg: String) -> ProviderResult {$/;"	P	interface:CommunicationProviderTrait
send_bytes	server/communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult {$/;"	P	implementation:Arc
send_bytes	server/communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult {$/;"	P	implementation:CommunicationProvider
send_bytes	server/communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult;$/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_data	server/communication.rs	/^    fn send_data_with_tag_and_data<T: Serialize>(&self, tag: &str, name: &str, obj: &T) -> Provi/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_string	server/communication.rs	/^    fn send_data_with_tag_and_string(&self, tag: &str, data: String) -> ProviderResult {$/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_vec_data	server/communication.rs	/^    fn send_data_with_tag_and_vec_data<T: Serialize>(&self, tag: &str, name: &str, obj: &Vec<T>)/;"	P	interface:CommunicationProviderTrait
serialize_test	json.rs	/^fn serialize_test() {$/;"	f
server	main.rs	/^mod server;$/;"	n
server_flow_tmp	server/server_interface.rs	/^    pub fn server_flow_tmp(&mut self) {$/;"	P	implementation:GameController
server_interface	server/mod.rs	/^pub mod server_interface;$/;"	n
server_utils	server/mod.rs	/^pub mod server_utils;$/;"	n
set_communication_provider_to_map_proc	server/game_parents.rs	/^    pub(super) fn set_communication_provider_to_map_proc(&self) {$/;"	P	implementation:GameController
show_game_details	server/server_interface.rs	/^    pub fn show_game_details(&self) {$/;"	P	implementation:GameController
show_map	map/mapinfo_utils.rs	/^    pub fn show_map(&self) {$/;"	P	implementation:MapInfo
start	time.rs	/^    pub fn start(&mut self) {$/;"	P	implementation:LoopTimer
start_game	server/server_interface.rs	/^    pub fn start_game(&mut self) {$/;"	P	implementation:GameController
start_reading_coordinate	server/communication.rs	/^    pub(super) fn start_reading_coordinate(&self) {$/;"	P	implementation:GameController
sub	map/coord.rs	/^    fn sub(self, other: Self) -> Self {$/;"	P	implementation:QuanCoord
subscribe	time.rs	/^    fn subscribe(&mut self, task: Box<dyn Fn() -> () + Send>, frec: u128) -> Result<usize, Strin/;"	P	interface:RxTimerTrait
subscribe	time.rs	/^    pub fn subscribe(&mut self, func : Box<dyn Fn() -> () + Send>, limit : u128) -> usize {$/;"	P	implementation:LoopTimerUnArc
subscribe	time.rs	/^    pub fn subscribe(&mut self, func: Box<dyn Fn() -> () + Send>, limit: u128) -> usize {$/;"	P	implementation:LoopTimer
subscribe_test	time.rs	/^pub fn subscribe_test() {$/;"	f
task_time_totals	time.rs	/^    task_time_totals: Vec<ProgressAndGoal<u128>>,$/;"	m	struct:RawRxTimer
tasks	time.rs	/^    tasks: Vec<Box<dyn Fn() -> () + Send>>,$/;"	m	struct:LoopTimerUnArc
tasks	time.rs	/^    tasks: Vec<Box<dyn Fn() -> () + Send>>,$/;"	m	struct:RawRxTimer
test	map/mod.rs	/^pub mod test;$/;"	n
time	main.rs	/^mod time;$/;"	n
time_task_reservation	time.rs	/^pub fn time_task_reservation(task: impl(Fn() -> ()) + Send + 'static, span: Duration) -> Sender</;"	f
time_task_reservation_cancel_test	time.rs	/^fn time_task_reservation_cancel_test() {$/;"	f
time_task_reservation_non_cancel_test	time.rs	/^fn time_task_reservation_non_cancel_test() {$/;"	f
timer	server/mod.rs	/^    pub timer: LoopTimer, \/\/This is doing tasks per the time$/;"	m	struct:GameController
to_string	map/mod.rs	/^    fn to_string(&self) -> String {$/;"	P	implementation:PMState
torus_form	map/coord.rs	/^    pub fn torus_form(&self, map_ptr: &super::MapInfo) -> Self {$/;"	P	implementation:QuanCoord
totals	time.rs	/^    totals: Vec<u128>,$/;"	m	struct:LoopTimerUnArc
unique_field_element_search_test	map/test.rs	/^fn unique_field_element_search_test() {$/;"	f
unique_points	map/mod.rs	/^    pub unique_points: HashMap<i32, QuanCoord>,$/;"	m	struct:MapInfo
update	time.rs	/^    fn update(&mut self);$/;"	P	interface:RxTimerTrait
update	time.rs	/^    pub fn update(&mut self) {$/;"	P	implementation:LoopTimerUnArc
update_coordinate	game.rs	/^    pub fn update_coordinate(&mut self, i: usize, v: Vec<f32>) {$/;"	P	implementation:Game
vec_group_eq	map/test.rs	/^fn vec_group_eq<T: PartialEq>(v: &Vec<T>, w: &Vec<T>) -> bool {$/;"	f
vec_group_eq_test	map/test.rs	/^fn vec_group_eq_test() {$/;"	f
wait_and_prepare_communication	server/server_utils.rs	/^    pub(super) fn wait_and_prepare_communication(&mut self) {$/;"	P	implementation:GameController
wait_until_clients_connection	server/server_utils.rs	/^    pub(super) fn wait_until_clients_connection(&mut self) {$/;"	P	implementation:GameController
width	map/mod.rs	/^    pub width: usize,$/;"	m	struct:MapInfo
wr	server/communication.rs	/^    pub wr: BufWriter<TcpStream>,$/;"	m	struct:BufStream
write	server/communication.rs	/^    pub fn write(&mut self, data: &[u8]) -> Result<usize, std::io::Error> {$/;"	P	implementation:BufStream
x	map/coord.rs	/^    pub x: f32,$/;"	m	struct:RawCoord
x	map/coord.rs	/^    pub x: i32,$/;"	m	struct:QuanCoord
y	map/coord.rs	/^    pub y: f32,$/;"	m	struct:RawCoord
y	map/coord.rs	/^    pub y: i32,$/;"	m	struct:QuanCoord
z	map/coord.rs	/^    pub z: f32, \/\/ clients(Unity) send z data.$/;"	m	struct:RawCoord
