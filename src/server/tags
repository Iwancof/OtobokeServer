!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/f6c7064a/
Arc	communication.rs	/^impl CommunicationProviderTrait for Arc<Mutex<CommunicationProvider>> {$/;"	c
BufStream	communication.rs	/^impl BufStream {$/;"	c
BufStream	communication.rs	/^pub struct BufStream {$/;"	s
CommunicationProvider	communication.rs	/^impl CommunicationProvider {$/;"	c
CommunicationProvider	communication.rs	/^impl CommunicationProviderTrait for CommunicationProvider {$/;"	c
CommunicationProvider	communication.rs	/^pub struct CommunicationProvider {$/;"	s
CommunicationProviderTrait	communication.rs	/^pub trait CommunicationProviderTrait {$/;"	i
GameController	communication.rs	/^impl GameController {$/;"	c
GameController	game_parents.rs	/^impl GameController {$/;"	c
GameController	mod.rs	/^pub struct GameController {$/;"	s
GameController	server_interface.rs	/^impl GameController {$/;"	c
GameController	server_utils.rs	/^impl Drop for GameController {$/;"	c
GameController	server_utils.rs	/^impl GameController {$/;"	c
ProviderResult	communication.rs	/^type ProviderResult = Result<usize, std::io::Error>;$/;"	t
accept_client_stream	server_utils.rs	/^    pub fn accept_client_stream(&self, mut stream: net::TcpStream) {$/;"	P	implementation:GameController
announce_wrap	communication.rs	/^    pub fn announce_wrap(&self, msg: String){$/;"	P	implementation:GameController
clients	communication.rs	/^    pub clients: Vec<Arc<Mutex<BufStream>>>, $/;"	m	struct:CommunicationProvider
clients_count	communication.rs	/^    fn clients_count(&self) -> usize {$/;"	P	implementation:CommunicationProvider
communication	mod.rs	/^pub mod communication;$/;"	n
comn_prov	mod.rs	/^    pub comn_prov: Arc<Mutex<CommunicationProvider>>,$/;"	m	struct:GameController
data_factory	mod.rs	/^pub mod data_factory;$/;"	n
distribute_map	game_parents.rs	/^    pub(super) fn distribute_map(&mut self) {$/;"	P	implementation:GameController
drop	server_utils.rs	/^    fn drop(&mut self) {$/;"	P	implementation:GameController
front	mod.rs	/^pub mod front;$/;"	n
game	mod.rs	/^    pub game: Arc<Mutex<Game>>,$/;"	m	struct:GameController
game_initialize	game_parents.rs	/^    pub(super) fn game_initialize(&mut self) {$/;"	P	implementation:GameController
game_parents	mod.rs	/^pub mod game_parents;$/;"	n
join_client_stream	server_utils.rs	/^    pub fn join_client_stream(&self, stream: net::TcpStream) {$/;"	P	implementation:GameController
network_buffer	communication.rs	/^    pub network_buffer : Vec<Arc<Mutex<String>>>,$/;"	m	struct:CommunicationProvider
new	communication.rs	/^    pub fn new() -> Self {$/;"	P	implementation:CommunicationProvider
new	communication.rs	/^    pub fn new(stream: &TcpStream) -> BufStream {$/;"	P	implementation:BufStream
new	server_utils.rs	/^    pub fn new(game: Game) -> GameController {$/;"	P	implementation:GameController
parse_client_info	communication.rs	/^    pub(super) fn parse_client_info(msg: String) -> Vec<f32> {$/;"	P	implementation:GameController
player_info_initialize_in_map	server_utils.rs	/^    pub(super) fn player_info_initialize_in_map(&self) {$/;"	P	implementation:GameController
player_limit	mod.rs	/^    pub player_limit: usize,$/;"	m	struct:GameController
rd	communication.rs	/^    pub rd: BufReader<TcpStream>,$/;"	m	struct:BufStream
read_by_buffer	communication.rs	/^pub fn read_by_buffer(bs: Arc<Mutex<BufStream>>) -> String {$/;"	f
read_string	communication.rs	/^    pub fn read_string(&mut self) -> String {$/;"	P	implementation:BufStream
send	communication.rs	/^    fn send(&self, msg: String) -> ProviderResult {$/;"	P	interface:CommunicationProviderTrait
send_bytes	communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult {$/;"	P	implementation:Arc
send_bytes	communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult {$/;"	P	implementation:CommunicationProvider
send_bytes	communication.rs	/^    fn send_bytes(&self, msg: &[u8]) -> ProviderResult;$/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_data	communication.rs	/^    fn send_data_with_tag_and_data<T: Serialize>(&self, tag: &str, name: &str, obj: &T) -> Provi/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_string	communication.rs	/^    fn send_data_with_tag_and_string(&self, tag: &str, data: String) -> ProviderResult {$/;"	P	interface:CommunicationProviderTrait
send_data_with_tag_and_vec_data	communication.rs	/^    fn send_data_with_tag_and_vec_data<T: Serialize>(&self, tag: &str, name: &str, obj: &Vec<T>)/;"	P	interface:CommunicationProviderTrait
server_flow_tmp	server_interface.rs	/^    pub fn server_flow_tmp(&mut self) {$/;"	P	implementation:GameController
server_interface	mod.rs	/^pub mod server_interface;$/;"	n
server_utils	mod.rs	/^pub mod server_utils;$/;"	n
set_communication_provider_to_map_proc	game_parents.rs	/^    pub(super) fn set_communication_provider_to_map_proc(&self) {$/;"	P	implementation:GameController
show_game_details	server_interface.rs	/^    pub fn show_game_details(&self) {$/;"	P	implementation:GameController
start_game	server_interface.rs	/^    pub fn start_game(&mut self) {$/;"	P	implementation:GameController
start_reading_coordinate	communication.rs	/^    pub(super) fn start_reading_coordinate(&self) {$/;"	P	implementation:GameController
timer	mod.rs	/^    pub timer: LoopTimer, \/\/This is doing tasks per the time$/;"	m	struct:GameController
wait_and_prepare_communication	server_utils.rs	/^    pub(super) fn wait_and_prepare_communication(&mut self) {$/;"	P	implementation:GameController
wait_until_clients_connection	server_utils.rs	/^    pub(super) fn wait_until_clients_connection(&mut self) {$/;"	P	implementation:GameController
wr	communication.rs	/^    pub wr: BufWriter<TcpStream>,$/;"	m	struct:BufStream
write	communication.rs	/^    pub fn write(&mut self, data: &[u8]) -> Result<usize, std::io::Error> {$/;"	P	implementation:BufStream
